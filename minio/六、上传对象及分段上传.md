# 1.上传对象

.引入maven依赖

```xml
 <dependency>
   <groupId>io.minio</groupId>
   <artifactId>minio</artifactId>
   <version>8.4.1</version>
</dependency>
```

上传对象

```java
package me.qiu.minio.client;

import io.minio.MinioClient;
import io.minio.PutObjectArgs;
import io.minio.errors.MinioException;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

public class MinioPutObject {

    public static void main(String[] args) throws IOException, NoSuchAlgorithmException, InvalidKeyException {
        try {
            MinioClient minioClient = MinioClient.builder()
                    .endpoint("http://127.0.0.1:9000")
                    .credentials("minioadmin", "minioadmin")
                    .build();

            FileInputStream fileInputStream = new FileInputStream(new File("mysql-5.7.36-winx64.zip"));

            minioClient.putObject(PutObjectArgs.builder()
                    .bucket("my-bucket")
                    .object("my-objectname")
                    .stream(fileInputStream, fileInputStream.available(), -1)
                    .build());
            fileInputStream.close();
            System.out.println("my-objectname is uploaded successfully");

        } catch (MinioException e) {
            System.out.println("Error occurred: " + e);
        }
    }
}
```





注意：s3Client.putObject(request)上传整个文件，在minio只会生成一个part.1

![img](https://cdn.nlark.com/yuque/0/2022/png/28915315/1653393577901-be00fb9a-dca2-411e-b01b-6c65ce16e934.png)

# 2.分段上传

### 2.1 默认分段大小

一般而言，如果您的对象大小达到了 100 MB，您应该考虑使用分段上传，而不是在单个操作中上传对象。

分段上传对象的大小必须超过5M（也可以自定义分段上传的阈值），分段上传将一个大文件默认分拆成许多5M大小的数据块分别上传。

![img](https://cdn.nlark.com/yuque/0/2022/png/28915315/1653390918222-24a84f2c-5b2a-479a-9919-6ba8c6f78ef1.png)

使用分段上传可提供以下优势：

- **提高吞吐量** – 并行上传分段以提高吞吐量。
- **无需从新上传** – 如果任意分段传输失败，重新传输该分段即可，不需要重新上传整个对象。
- **暂停和恢复对象上传** – 您可以在一段时间内逐步上传对象分段。启动分段上传后，不存在过期期限；您必须显式地完成或停止分段上传。
- **不知道对象的最终大小仍可上传** – 您可以在创建对象时将其上传。

提示：后面两个优势特别适合上传流式数据不断追加到大文件的场景

```java
 minioClient.putObject(PutObjectArgs.builder()
                    .bucket("asiatrip")
                    .object("my-objectname")
                    .stream(fileInputStream,
                            fileInputStream.available(),
                            //设置分段大小
                            10 * 1024 * 1024)
                    .build());
```

也可以使用高级API，默认分段为5M.

```java
import io.minio.*;
import io.minio.errors.MinioException;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

public class FileUploader {
  public static void main(String[] args)
      throws IOException, NoSuchAlgorithmException, InvalidKeyException {
    try {
      // Create a minioClient with the MinIO server playground, its access key and secret key.
      MinioClient minioClient =
          MinioClient.builder()
              .endpoint("http://127.0.0.1:9000")
              .credentials("minioadmin", "minioadmin")
              .build();

      boolean found =
          minioClient.bucketExists(BucketExistsArgs.builder().bucket("my-bucket").build());
      if (!found) {
        minioClient.makeBucket(MakeBucketArgs.builder().bucket("my-bucket").build());
      } else {
        System.out.println("Bucket 'my-bucket' already exists.");
      }

      minioClient.uploadObject(
          UploadObjectArgs.builder()
              .bucket("my-bucket")
              .object("my-object")
              .filename("/Users/qiu/Downloads/mysql-5.7.36-winx64.zip")
              .build());
      System.out.println(
          "'my-object' is successfully uploaded to bucket 'my-bucket'");
    } catch (MinioException e) {
      System.out.println("Error occurred: " + e);
      System.out.println("HTTP trace: " + e.httpTrace());
    }
  }
}
```

上传完成后在磁盘上的存储结构如下：

![img](https://cdn.nlark.com/yuque/0/2022/png/28915315/1653395301634-9514278e-9f22-4013-9389-d017203dfae0.png)

![img](https://cdn.nlark.com/yuque/0/2022/png/28915315/1653395343675-41a26550-3556-4ea3-8d1e-ee3a2c5293a1.png)

# 3.S3 JAVA SDK 分段上传

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

    <modelVersion>4.0.0</modelVersion>
    <groupId>minio.s3.example</groupId>
    <artifactId>minio.s3examples</artifactId>
    <packaging>jar</packaging>
    <version>1.0</version>
    <name>MinIO S3 Examples</name>

    <properties>
        <maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>com.amazonaws</groupId>
                <artifactId>aws-java-sdk-bom</artifactId>
                <version>1.11.837</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>com.amazonaws</groupId>
            <artifactId>aws-java-sdk-s3</artifactId>
        </dependency>
        <dependency>
            <groupId>com.amazonaws</groupId>
            <artifactId>aws-java-sdk-sts</artifactId>
        </dependency>
        <dependency>
            <groupId>com.amazonaws</groupId>
            <artifactId>aws-java-sdk-iam</artifactId>
        </dependency>
        <dependency>
            <groupId>com.amazonaws</groupId>
            <artifactId>aws-java-sdk-kms</artifactId>
        </dependency>
    </dependencies>

</project>
```

2.初始化S3Client

```java
AWSCredentials credentials = new BasicAWSCredentials("minioadmin", "minioadmin");
ClientConfiguration clientConfiguration = new ClientConfiguration();
clientConfiguration.setSignerOverride("AWSS3V4SignerType");

AmazonS3 s3Client = AmazonS3ClientBuilder
                    .standard()
    .withEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration("http://127.0.0.1:9000", Regions.US_EAST_1.name()))
    .withPathStyleAccessEnabled(true)
    .withClientConfiguration(clientConfiguration)
    .withCredentials(new AWSStaticCredentialsProvider(credentials))
    .build();
```

3.分段上传示例代码

```java
import com.amazonaws.AmazonServiceException;
import com.amazonaws.ClientConfiguration;
import com.amazonaws.SdkClientException;
import com.amazonaws.auth.AWSCredentials;
import com.amazonaws.auth.AWSStaticCredentialsProvider;
import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.client.builder.AwsClientBuilder;
import com.amazonaws.regions.Regions;
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3ClientBuilder;
import com.amazonaws.services.s3.transfer.TransferManager;
import com.amazonaws.services.s3.transfer.TransferManagerBuilder;
import com.amazonaws.services.s3.transfer.Upload;

import java.io.File;
import java.io.IOException;

public class MultipartUpload {

    public static void main(String[] args) throws IOException {

        String bucketName = "my-bucket";
        String keyName = "cenos.iso";
        String filePath = "CentOS-7-x86_64-Minimal-2009.iso";

        try {

            AWSCredentials credentials = new BasicAWSCredentials("minioadmin", "minioadmin");
            ClientConfiguration clientConfiguration = new ClientConfiguration();
            clientConfiguration.setSignerOverride("AWSS3V4SignerType");

            AmazonS3 s3Client = AmazonS3ClientBuilder
                    .standard()
                    .withEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration("http://127.0.0.1:9000", Regions.US_EAST_1.name()))
                    .withPathStyleAccessEnabled(true)
                    .withClientConfiguration(clientConfiguration)
                    .withCredentials(new AWSStaticCredentialsProvider(credentials))
                    .build();

            TransferManager tm = TransferManagerBuilder.standard()
                    .withS3Client(s3Client)
                    .build();

            Upload upload = tm.upload(bucketName, keyName, new File(filePath));
            System.out.println("Object upload started");

            // Optionally, wait for the upload to finish before continuing.
            upload.waitForCompletion();
            System.out.println("Object upload complete");

        } catch (AmazonServiceException e) {
            e.printStackTrace();
        } catch (SdkClientException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
```

### 3.1 设置分段大小、**并发数量和阈值**

设置线程数量为5

设置超过100M的对象才启用分段上传

设置分段上传的数据块大小为100M

```java
//线程数量为5
int maxUploadThreads = 5;
TransferManager tm = TransferManagerBuilder.standard()
    .withS3Client(s3Client)
    //对象大小超过100M才启用分段上传
    .withMultipartUploadThreshold((long) (100 * 1024 * 1024))
    //数据块分段大小为100M
    .withMinimumUploadPartSize((long) (100 * 1024 * 1024))
    .withExecutorFactory(() -> Executors.newFixedThreadPool(maxUploadThreads))
    .build();
```

由于设置了分段大小为100M，因此比之前产生的数据块较少，如下图：

![img](https://cdn.nlark.com/yuque/0/2022/png/28915315/1653394925931-2a4329b9-db4c-4abb-af44-9cb9cef9017d.png)

### **3.2 跟踪上传进度**

```java
ProgressListener progressListener = 
    progressEvent -> System.out.println("Transferred bytes: " + progressEvent.getBytesTransferred());
PutObjectRequest request = new PutObjectRequest(bucketName, keyName, file);
request.setGeneralProgressListener(progressListener);
Upload upload = tm.upload(request);
```

### 

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |