## 一、推荐写法

### 1.重复的配置可继承自父级

例如：

```nginx
server {
  server_name www.example.com;
  
  location / {
    root /var/www/nginx-default/;
    # [...]
  }
  location /foo {
    root /var/www/nginx-default/;
    # [...]
  }
  location /bar {
    root /some/other/place;
  # [...]
  }
}
```

推荐写法

```nginx
server {
    server_name www.example.com;
    root /var/www/nginx-default/;
    
    location / {
        # root继承父级配置
        # [...]
    }
    location /foo {
        # root继承父级配置
        # [...]
    }
    location /bar {
        # 覆盖
        root /some/other/place;
        # [...]
    }
}
```

这样在添加新的location时，可以避免重复配置。

### 2.不要将所有请求都代理到后端服务器

不推荐：

```nginx
location / {
    proxy_pass http://localhost:8088;        
}
```

考虑到很多请求是访问静态内容（如图片，css，javascript等文件）,可以使用缓存或者配置静态目录来减少发送到后端的请求数量，这样可以减小后端服务器的开销。

```nginx
server {

    listen 8002;
    server_name ruoyi.tomcat;
    root /home/www/static;

    location / {
        try_files $uri $uri/ @proxy;
    }

    location @proxy {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        proxy_pass http://localhost:8080;
    }
  
}
```

### 3.若非必要，不要缓存动态请求，只缓存静态文件

nginx关于缓存的指令非常多

* [proxy_cache](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache)
* [proxy_cache_background_update](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_background_update)
* [proxy_cache_bypass](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_bypass)
* [proxy_cache_convert_head](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_convert_head)
* [proxy_cache_key](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_key)
* [proxy_cache_lock](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_lock)
* [proxy_cache_lock_age](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_lock_age)
* [proxy_cache_lock_timeout](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_lock_timeout)
* [proxy_cache_max_range_offset](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_max_range_offset)
* [proxy_cache_methods](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_methods)
* [proxy_cache_min_uses](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_min_uses)
* [proxy_cache_path](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path)
* [proxy_cache_purge](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_purge)
* [proxy_cache_revalidate](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_revalidate)
* [proxy_cache_use_stale](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_use_stale)
* [proxy_cache_valid](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_valid)
* [proxy_no_cache](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_no_cache)
<br/>由于nginx服务端缓存非常复杂，在使用缓存的时候，我们要清楚的知道在什么条件下，哪些文件会被缓存。
  在配置文件中，最好能够清晰的指定哪些文件使用缓存。

### 4.检查文件是否存在使用try_files代替if -f

不推荐用法：

```nginx
server {
    root /var/www/example.com;
    location / {
        if (!-f $request_filename) {
            break;
        }
    }
}
```

推荐用法：

```nginx
server {
    root /var/www/example.com;
    location / {
        try_files $uri $uri/ /index.html;
    }
}
```

### 5.在重写路径中包含http://或https://

```nginx
#推荐写法
rewrite ^ http://example.com permanent; 

#不推荐的写法
rewrite ^ example.com permanent;
```

### 6.保持重写规则简单干净

例如下面的这个例子可以变得更简单易懂。

```nginx
#复杂的写法
rewrite ^/(.*)$ http://example.com/$1 permanent; 

#简单有效的写法
rewrite ^ http://example.com$request_uri? permanent; 
return 301 http://example.com$request_uri;
```

## 二、注意事项

### 1.正确的配置未生效，请清除浏览器缓存

当你确定修改的配置的正确的，但是未生效，请清除浏览器缓存或者禁用浏览器缓存。

### 2.在HTTPS中不启用 SSLv3

由于 SSLv3 中存在 POODLE 漏洞，建议不要在启用了 SSL 的站点中使用 SSLv3。您可以使用以下行非常轻松地禁用 SSLv3，并仅提供 TLS 协议：

```nginx
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
```

### 3.不要将 root 目录配置成 `/`或 `/root`。

错误用法

```nginx
server {
  #错误用法
  root /;
  
  location /project/path {
    #错误用法
    root /root;
  }
}
```

### 4.谨慎使用chmod 777

这可能是解决问题最简单的方式，同时也说明，你没有真的弄清楚哪里出了问题。
可以使用`namei -om /path/to/check`显示路径上的所有权限，并找到问题的根本原因。

### 5.不要将部署的项目拷贝到默认目录下

升级或更新nginx的时候，默认目录可能被覆盖。

参考文档：
[https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/](https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/)<br>
[https://www.nginx.com/resources/wiki/start/topics/depth/ifisevil/](https://www.nginx.com/resources/wiki/start/topics/depth/ifisevil/)

